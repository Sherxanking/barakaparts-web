/// Excel Import Service
/// 
/// WHY: Allows bulk import of parts/products from Excel files
/// Supports: .xlsx, .xls formats

import 'dart:io';
import 'package:excel/excel.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import '../../domain/entities/part.dart';
import '../../domain/entities/product.dart' as domain;
import '../../core/errors/failures.dart';
import '../../core/utils/either.dart';

class ExcelImportService {
  /// Pick Excel file
  Future<Either<Failure, File?>> pickExcelFile() async {
    try {
      final result = await FilePicker.platform.pickFiles(
        type: FileType.custom,
        allowedExtensions: ['xlsx', 'xls'],
        allowMultiple: false,
      );

      if (result == null || result.files.isEmpty) {
        return Right(null); // User cancelled
      }

      final filePath = result.files.single.path;
      if (filePath == null) {
        return Left(ValidationFailure('File path is null'));
      }

      final file = File(filePath);
      if (!await file.exists()) {
        return Left(ValidationFailure('File does not exist'));
      }

      return Right(file);
    } catch (e) {
      return Left(ServerFailure('Failed to pick file: $e'));
    }
  }

  /// Parse Excel file and extract parts
  /// Expected format:
  /// Row 1: Headers (Name, Quantity, Min Quantity)
  /// Row 2+: Data rows
  Future<Either<Failure, List<Part>>> parsePartsFromExcel(File file) async {
    try {
      final bytes = await file.readAsBytes();
      final excel = Excel.decodeBytes(bytes);

      if (excel.tables.isEmpty) {
        return Left(ValidationFailure('Excel file is empty or has no sheets'));
      }

      final table = excel.tables[excel.tables.keys.first]!;
      if (table.rows.isEmpty) {
        return Left(ValidationFailure('Excel file has no data rows'));
      }

      final parts = <Part>[];
      
      // Skip header row (row 0)
      for (int i = 1; i < table.rows.length; i++) {
        final row = table.rows[i];
        if (row.isEmpty) continue;

        try {
          final name = _getCellValue(row, 0)?.toString().trim();
          if (name == null || name.isEmpty) continue; // Skip empty rows

          final quantityStr = _getCellValue(row, 1)?.toString().trim() ?? '0';
          final minQuantityStr = _getCellValue(row, 2)?.toString().trim() ?? '0';

          final quantity = int.tryParse(quantityStr) ?? 0;
          final minQuantity = int.tryParse(minQuantityStr) ?? 0;

          parts.add(Part(
            id: '', // Will be generated by repository
            name: name,
            quantity: quantity,
            minQuantity: minQuantity,
            createdAt: DateTime.now(),
          ));
        } catch (e) {
          debugPrint('⚠️ Error parsing row ${i + 1}: $e');
          // Continue with next row
        }
      }

      if (parts.isEmpty) {
        return Left(ValidationFailure('No valid parts found in Excel file'));
      }

      return Right(parts);
    } catch (e) {
      return Left(ServerFailure('Failed to parse Excel file: $e'));
    }
  }

  /// Parse Excel file and extract products
  /// Expected format:
  /// Row 1: Headers (Name, Department, Parts)
  /// Row 2+: Data rows
  Future<Either<Failure, List<domain.Product>>> parseProductsFromExcel(
    File file,
    String departmentId,
  ) async {
    try {
      final bytes = await file.readAsBytes();
      final excel = Excel.decodeBytes(bytes);

      if (excel.tables.isEmpty) {
        return Left(ValidationFailure('Excel file is empty or has no sheets'));
      }

      final table = excel.tables[excel.tables.keys.first]!;
      if (table.rows.isEmpty) {
        return Left(ValidationFailure('Excel file has no data rows'));
      }

      final products = <domain.Product>[];
      
      // Skip header row (row 0)
      for (int i = 1; i < table.rows.length; i++) {
        final row = table.rows[i];
        if (row.isEmpty) continue;

        try {
          final name = _getCellValue(row, 0)?.toString().trim();
          if (name == null || name.isEmpty) continue; // Skip empty rows

          // Parts format: "Part1:2,Part2:3" (partName:quantity)
          final partsStr = _getCellValue(row, 2)?.toString().trim() ?? '';
          final partsRequired = <String, int>{};

          if (partsStr.isNotEmpty) {
            final partsList = partsStr.split(',');
            for (final partEntry in partsList) {
              final parts = partEntry.split(':');
              if (parts.length == 2) {
                final partName = parts[0].trim();
                final quantity = int.tryParse(parts[1].trim()) ?? 0;
                if (partName.isNotEmpty && quantity > 0) {
                  // Note: We'll need to resolve part name to part ID later
                  partsRequired[partName] = quantity;
                }
              }
            }
          }

          products.add(domain.Product(
            id: '', // Will be generated by repository
            name: name,
            departmentId: departmentId,
            partsRequired: partsRequired,
            createdAt: DateTime.now(),
          ));
        } catch (e) {
          debugPrint('⚠️ Error parsing row ${i + 1}: $e');
          // Continue with next row
        }
      }

      if (products.isEmpty) {
        return Left(ValidationFailure('No valid products found in Excel file'));
      }

      return Right(products);
    } catch (e) {
      return Left(ServerFailure('Failed to parse Excel file: $e'));
    }
  }

  /// Get cell value safely
  dynamic _getCellValue(List<Data?> row, int index) {
    if (index >= row.length) return null;
    final cell = row[index];
    return cell?.value;
  }
}

















